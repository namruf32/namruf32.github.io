<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder=""
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="MEMBER LOGIN" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3066c144f39d6877873c915bb9b4393ddaf700cf7e9a8cff8667f211d49fdfde9dab73fd0dbe98b6f7549ebdb6c177a6d37c3ec2f8d45831cfa86470cbc44dece747884ae4c5239b0dd05950f2ab7924f2fb4c369ba6a592ef4db8382fac23a3a23db74dd2ca47ad29e0d46ca27e8f76a5f60ed239ae8e0aca345250248f0dbac73dc96e98b5a2db411baef501716acf7c91895a87a7b59c39e084719268f441dee4fd791459d3806fec13085dfdac52be737ec50e19bced61fb0b68094cc5be6d7ace6c8b4bc7b53623edff2c3412d4e82978a1d263fa036984cf3ae50d9c4bb5568d23b773548e034f0e8101acb72b331825b1f10fdd15bb691abb6218b5d58a740c97fb00fa2e47076b923e5eaffcdfe2bdc9e81dd7953cd91148028fdc3f02c8976a9295de656c7d2478d5695cc2503a2581ec20ac9e0058484380c3b9cb93eaa9fb9e64fefc3e5d9f396d346fac90ac523f6d196dcef84e36c396254707fff822e3283ae6c2841195241a5d6474055cbeadacff03f475e11be9d09a69630cfb5f563b9847ad8afbf8ac38c725170951813e76c934de7bf38e817c7fb7915c51b303561762b7d9db32f851feecd87c4db97bc1c524b024c8bff0ffd804804af81331017e6a8702c60541dc7636a82db96e796dc3d3b027756f2ecb272cd45b27444fbba53a3366188d41080bc45dc6b9b8d4b85f1c24efbcdba6b1ac8eec0dcdc87561255d9c1e127d61cc05ffa40e0ac0d56f59e9758c6927e7a0a0e0450790eef32968ab00e4fa30f43bda14fc26cd843daf57169d3261635295c4119d2aa88dd4e351d8d869ab31024bd2bacca6916b770a74a6c0e696c1cf2e82cedf519481e22024e6770f095d97ce7efd6671614f99f0bd4a4ad56ce1e8c70ade471f39a9faf8731269a82c93fa6fe3fbffeb90fd7e43ff26b9856fa1e49ceae83ea7647b13b22c7d2f95917fa59e968a7e642ea5eff31342113d1671b6b4051df2e46d93b43399f0b55eafe0f3e67c40047554a1d2dcd40c7daf6007eca3b7f38e23d386d6c9b36fed253e5501aa8d67f8d279f5329aed665f6cf30b87e4ec9c2c3dc544c4db4335d8331bd726e3900b20b2772a82d2c3843969fa4de77d7f6c300824306e42b1c27287ebe69eaff0a5863e2ca724449c7ee2eb0147b87f9275d63ceab8c3a68db6aedc587a06cfee9cedc37d5ad0e288b3a236ca0f0942d45649a7929baec6ab89efdbd280a8222f25317fd4c79770f31c1cd5e6cae06e66b00cd163ca1ff9fa236032e40d309ac4046cebbb4e97efe538c4c0651ee924bf3d79403b9096b288698a36814d027f5904db193a1a065e5b8352456684fff499fb2012e38bf889f06e29e7816f5fd939464f59a56596c046fc5221838536d2981814b75e0ef178a036fdb58764b1a7764d659085887cc5df6dddd552c90e37c3022596623a1b835a96ce2ec5289fc7dcf5f9587375a187c7132f867f3acf258ec42226cc75d15c66e23510869caf55efc74d81e176080e9aab31602ea64d8b86b5353775866cc0fbb2dc0265cad1e8f01edb4d4da2217b560ddb56f2492b04936d2521ff6a9138fbaec88fa9d92e32f8166f97a744b46b2ca1acb5a8380a1f5498b1994a18b76c856fef7cb562f15bea1dbc149feed4f315f1af446fa70ad31efaa5dd56b6e76d30cbe3ff3afcc528907c0e78f8b5408152992fb125be2c379c49858c0e2d5ce58f3cb947fedc1f0f05f968ee7431f183a729b5ad7947deed9be3ebd59f911ac798ae8fad6ada3850c9990133131df141a40010995c9a835c2b90ea1ade2a2d195474267306e84f73ef758f56b759c96667626fa2e4dde2e4c3299775cc086d59cf513a1cad90097e777070fb5b1079f91bf83780bb166d2af4248c6f0ae61d76b222c5431912c077db5e7264f2c93321b1f435621639b2004a1c030cfd057a453130996e2e97949c74ce259075a4c45c495defcc60627fefe43ec5ea1acd3a1120d8e0cd0d934e7fb1dc8e7d5f55c4318b3eddcc9783abb26542c2852f550a7eb8645c25d2c2e552a52f992260d162ea354d3009e6359f0bd6fae73b808a15a6a90289142241ffec4cdc82de77f068e88127f7194abf90215a523509cfaacc6112ad9a780990cb55727fb7bd126cae97c9afd47b76cad0f6a6b4b8af6bd12752c19c932b2558d8b356824668c780d3b605c418003516cb678c87499109749d69f304d86a93816cdb68fa87be9e85c5c4c4eef3ead22e97ecbfc0f5041f34f1e1aa09206673e1095069b88d4dd1547a64aacc1ba2b2addd9dff4f65b790eacd1e810c1724b4fc49cd01492a093ed7aba7693c53e5246eff486356dc5076db5f7cbe1c0e792d050940ae2a2e657bb43f1c98452ad97ed803a42e11bda9c833343d92e8fbbe636d1838c7b2440fe7c352607d58218a601064a3da9c8570b71c469c18860afcbba6356268d1ef56b97d63298887cb3f4bc115362440aec03f29aff3c08d986f7f5affdfcbd8df5243757485ed76a1d7f9b8c12058b22f488d34a7d0257e1f9acac197f7b6ddd1369bf98b22dcaaa593ab79a906f5695327917e9523c5ed664a9f1cf974c81be78d5e6dee59c8d23863a975e7b8b37d19bfda708a5ae4e2f10d2a2affe1a292c833e5e59e0e6a1c71a7f52ab8d859cf33ab4687968c915ea36536839e848a29fc457c8ef3bded152971784988c3d0046bbd726eb5bc452d184c601f1ce3499b936c63260bb05a49f61406d18d5a2275f607507ca4d8750c0cf02ab3d823531c0c27037561dbca90c5d816803418855a7c5a229b00da5574a1ea550ac1810b96c2997db5c2590ed93b1e0d3ee90a07f32ee27d8c168e411cd504dd932297d93bb0f502d002c12d3ec6ed5a8f3e723739784e457d156913d94eed0174a7ffd3965c2205ff6e68f39574fd3b321e57650913983faae8e3cb16fc2152cfbb58613c04f55227caa78b88d1f6769f6b1acc5d0a52b2a9f41da18c5817325e203225ac1881a204a236c9b6c3a1ae036c2f28ec7147a49513d3627125beab059fbe7a30568c560bd6e5b3410cdccf814b9a9fe334e2ff012866203b77a9b740639c0cbfdeecbf27b45557c7b87bef222cbaa22ef71a888b807247e79d73c12bff37f2c885313c92236a130a95a6027ff3a4f07a02aab9e75e42030faf9ca2e74f54363672f9087e96982f52ffa4bb46d684e09eb07c939c35ddca084eb6242f4300ffce55c35e4d03c9ddeca27bfbf8bc7bc39d94d7653c43c6eeeb1f80700f85e0bc46ef8c523d523fd5d3823552330b4044c393d46a05d6ca495095acd6961911af6d7766eedd9b6f3fc6a5f039fb15deea3ddb77d23b65d9d40e0ec386b421787d4efc5d74934e78d994962bfb08dcf542138ea2ef61779247c80bb671b012c4e079282e5cfcf22cb43f3a22e2d59bdee6292d641e9228aacbb82ff24d61608fa437a443d7693409864a44850de8e83a5aca45c4621c70900a7121b8782397bfff329999932b4b7d224f5b024e3c7f89d7c1703acb62ccbbd8d551c0e92cf1bb60456399308c1b86b4300ac5c0b846138ed9a3582d7beab33b7b9dbcfa945ed9ff0ec966eaca1971873c575fdc3774b8c86c5f9f1e9bff472bf7c3660e3a163c9a578a9be86a000fe2f52e6663c09b7c2f3ab6de586a06568f65a0bcab4bb8e63884ab8fbf39532906b2851bc6d459466bf0ce03559e77d05446e0119260164645ee0488c48f88ee15042d79808dbe1ed176e9f7a41cb8f7d54016b1b39a9d4f8cb6390b779d249d3c6f672c22f97722a8331606c01f1815f61f301afeb259ae08e33d060c5cf6ae484c09053959e98ef3b8a7ea5cb9013905e0992e06c91570734286891e4a3bbcc1b5a5c868bf0b50cd7ded9a89c7965f395e24ca8c7bb5ed2eb801c39d3051a87daa43380b020590b783511de51fa1d713b1b391e928c6b027ab79d015cc2fdd215fdd6437a514c3dbab4cee68051aa89a1797d8e438b40fb4cd18bc6eafacdb706e4c885b95f1afe863d0bc12ec158184344d2b046453d9607d0aecc26cc3f6d809a77539924236df66ef405573e5be629e1f2284ba5b4af9213c372e72be7ca42edbfeb97c1a106885c9a351773e47f6cb8b6c7473eb6eec7544343ad6acb443bf59b73aa033cef2b9028c187e3fe72e4270454256b7b2b1cd133424dc7376cb67b912e3d001aea808733148791c732de1312b21766867222bef9166d139d3f28b1d08011ec1611d805604cda9434e48d0ee14e75bfcb3777426e77222981c926ab17f50c0917831650d4706ffad8b3f0e3cdf5e8548b025419e6759d60a88abe7513047f5b1e4a0db3992f7fa544298cd8550a05b053eef451fe2031d735d1e7d0bb54526f406714ec96049da3c2490cfbc16b9527ba9d4436114fcf144b509b6d08766dd37241f4e8ec58b01a644a13a39dcc5a41ffc67a257232b06ec2dc0e083a5bfaeea4279c072a3d2a24e9b6d06ec2bc133155a4e23793420985fafbb21b480688bafaecea1dce8e3c9a1685213da0116950eebf09d5a24de61d149310dce3c17155b8862e4a19b82cb4ba2f268e6358db24de070c19bf6d2ecea85bd0356cf6af3e2814c768c986852ae1d738290f30a99affca5d122141bad44314dd4a364e6fdc546db5c3c9593d96da572d04019423b034354a51db02457a4e67283c49c3ca9a421046621844cc2436cf1baa1a6932048d64fe15adf5c6b7122f5b54d1e6c06bd9b96ce31eeffc2a08cfb696dc05fa424987fd1be53f8e239ad18e0d5038dd476d9126c71665d4564067e793fe3066c649de5b60ec7c9f81c99fd0e70cd6e7e37a7f0037fb007f3ad1cd61dabc962dff64bc8f08d7c91d42f1bb153966553651bbfdac9ec477c6506fdcf885a00336a040e9799e1612c86b46933152083351ab23c46c87a08aa9a75dc71298a8d45586e737cd6f2fa74be053d8d86a431fd859a0f5fac93385c84ea05556df2a017144875b7742cba00848d0d84446c1e85b14118402bcde7149e8327835252ca0dea929c73f5ca73148b7df7dbf6ae4afbfbfdd628b3c91454de1e19599aa473453624ee3e51a682d75410e6ff954fc387215276e676df0f7f10ae4b06e84bfdd678784be47abe6b03d1b520564ecca838c6e0549d71fc35b253b68d05231e377cd7e744656b097440260a251d93315da02427d3f30d8ec6890f4736113d3e351e357df81469a76501d032c4328d777697bde0a9de1c81cc321f7bafb1eb19ce27117fd0146fd7ab06f07f323ef194e875424de692f6d2c334052b9f7736bcacd641fe01c7f0f38b75ead7d0d64a7cc5e43c6d9063f467a48ebc5ea9c72e6f855f170549e6fff1abe3579aabe435eb8c6f147239ca0232dae2922ca3da4e106b42d23132b7a738e0a7158523a7fe17b4678b3bdc665f7de7357e08d0d1e16435823b6f2b5cf39c8355ae4de37126eea0cc7564f9670455115e5dfe3a7e622207e28d7141789206403a9638e1e64ae1986f99c78eab3dc84e6faa224a8f971ba3b99f5d83c881ecdc38c02ec19f5bb8201a5ba4e8653e6c7cd6adcc98cfdd48651582d13924149ccc8425ec142b2b1b256b5f3f7375532072fde3a167ed77be8f7d2a32cf017b2837a7ed9bb3366577d6e6d07e877103834757e920bcee8c61ee53fb7a25014c97c6fc68830b92d64a61dcb9de0fe5c90d344aa72349ed7b5bd430ec2b60a102fac4383607ce3db3b0629077f764625b2c27988b169f26c49989737d590b5fd2fe54686404274efba467be4d241aff26f10f638c6ee38c667fe083b9f7666158e7fc7ca3063c1b969974a6deb96c1989e96ae2d4bf0eef2def9a52292255c4a5c76c0aea1d1a360b7bad17a3019100a9903b6ce2f0f631d86805cd813937e151d15cca367b617384faec9cd8ed875e0c0f1edcff87ed5401e5421b944561fc89d0066d0ecd27aa0b4a73e0dbbed8c73d465be8a96e8211c4cab288b2b9a09a5770dad395855ea511f5601e626830c7ef91d4a62ee1ef7357b147d5efd996c760e02e2e28c35561caeebfeb83e436b07a27f859a8e10ff17d75bb018b5e3c9a7423c53e0557b8ba11c46344a6fbec07996cfc6478f026d20bcecad9e9b55bb521d0f219bf25543491d3f591a9b2744acd2b06cb40cb0936157d11996b8c5eca739593220857a91ed3d59db3cd1e1fa7a2b0bf120ac834d87a8a56a14b944a53665d1d47c0a27f411bae4093697f13165b54b38ff24da2c4716fa1810899a88e8e1f315b9a599ee21aa12930a88e5b48c1e39c17bb4cd252e490875e3ea8887cbefe461d13020ba1b694868d25f8b39a52b92f2f857ecf8d189841d09d9c76e49c7ba6964788891226b54512b6e40e714e614c5398320b3ee0b4e1362204888e79af63074dff24afba52d900b9a92fe8af616170583bfaa734f85edc135a931e4e2b27dbb3a84f9bd072e6af983b82437ac81676295c8f0f4480f2686194d9ad7e3c482f39f10ef47efc346979460c24abbf5ec7c811bb4b6bb0cdd5e9d6ecbadadfda185ad44b9acd9afdb2060861f9deca51a33f65e1ec4a0a990b3fa9f19a541e893655281a72299ac7f75b52f89b79f435bf7c19d1e2f9bb9aef3d807c627052caeb31373d1d192c8f5a39fc75e485334d99ce2c83a366cf46aecb40418d0bb293fa91afdcb437eb49fdce1a5865095d5df2cd07f5d5a6b45e5a4820ddeac20cbdb17fa96ab0677658c3a761a61be6bbca3251499bc17c55d206d61af81c9231cec131d6125ceb6b02fba5798529c128ae5532bfbc3f2169fb62ab12e8ce9404fe01eaf0b2945ee7f55ab830d4978e8f6b88abf95f39af244bec322b8211df2ef661d1a2a66ba96eb20af3d13a4a7577d6bfadff7e603b0097d9db9896c12012152b81afc1b3805f28578604e47f1101a72cb87e934588a212bc2ecdd53b5aabd7017b94d85f319c37c87fabc0049e963bfe17ba1ae3bc8f88a67f390b8e4844b6239c4d81266396ab6c3a2badaad8b7d3d324f5e92e4e7a98d5783d1e0d5054d1973405667071dbfd19763f103147e2a03c2eecdec55ec6cd47cf41d49c66afca46ae231b6053d940a135be210cd84e5d6433ae7df4e05bf42986ea2b967b5f3dfebe3e00df65ddfd79019cbf7723a005acfdcfb39d3b3ae9f634e979c4d57d9f7b87c9349646a0b84d70864c056c5f7d78036426726c0caa0011bb3f28181d653ad4135bd14d4249b83492f7b1d83eae2b0694e72f879b6c5d9244e7f3ac4509b674e50ab6b2c3dd61211da2f475d2813c0a8a1eba3052259f5802918b6ad242293c332ec674d8e1e6cacadbe268764184c06040fdee8eb4783a1e07910a1dcbd299d8cab21a82f5b57e025a4018d8b58d8ede715840dbf81a2e415284f893e4c50829b491cfccbdfcb88b7456262f6069ea0195bb08bb2ab1b3a3fc74f86d9e6fc82aab1842c4329f9dba71dd13f922df606c57a839ff0919034d3c751539badacd9068a75818e72f794146ac6d6e9eb771580f2e86ceb567da62db0cb8c6d2ad7d48735ba02be69d2f0fc1a5b2872efac423a161503e7382363c14442999e8a6bb0f5332f0fc1b428aec87aa09663caba15068e40ed64bb658b1945b106815f2d7a7de956ba23fc8a1c34238e07a1f027f3296513b3ae077ce18a5643ba3fd7c665c90d87cf2a833b47d5179f89d421aaec2c4cbc01e2ae50fef36fe9a9effdfb8dcd33b027734773ebf850a4bf598b70bb775c4de8331ec20688c3c6215c3dadc326e3490b14794e06a12bfc9ce594fc78161732cf60b65988808ba3b3bce8aeb92bcff973077e0053867fc6d993b77e69039c4113200c94ff0d2dd24a960af66b1e18c0f044ccc40578c16707f6cc68c82e60784f874d031882b2517a4703dbef1d6a693039c0cd8fe1b5c017273baf8ec6a58aebd081045fe9aa3470fa42b4a5d1bf9128563d6e82c81742e6cd164c81a1d147117d97ac4fd68d1ab279c857a53bdd2055120535151be456c19332c27bc9105ca05ec47ff1a721e949fd68586ec9a35e0209a91c5666bfffba7cc28aac72721ae904cf217cee2305b56e849f98bbd9c98db0f60ab6c83c70157ad28035b3e45ce6bd6a01605cf4fbfc5a32c58b513a0149a623f6cfc2301d61d40bd021eb7f4bf0cb5dfa8dfd7db6214f997af99d9f7fdd8ef429aef49556552040e4e224992b189029acbeea1f4e5d9fa4a6d327540f197602d2954d5febc0ab71802ffb668b2e6b9a1623669b218849ca510890ad1bf1622e03fdc030f2753b492284323d12e4ca7edc0ed4d128b650058d377bc6d08cd46e47fe7958fe94d48a3d8ed6f8ea42041944bff019a5da3f57d09a909b7c85b67c9402c2126fc27bbd22fc5fc9b3256aff73fbdf08a28faae1a291e16ca08d42f60cc02dd3bdd0915a51b128ee707478b790cb5757bffc7b90f8fa987d49645bf563fffafafa3899e29aed4a9ccb5e51bb91549bc3cea326d5f607f479717b8c8b30f9c079238438a1d692934ad1e400f6b185600021bd8f8b8cdeac09ed9b83e0f94e7797801f6fe97affb35f2004b8c6ba0f306a7611f61027ba4d70ddaddbe509ba695e5142c95ed05811dd0c1722ff097cbbd0bdff8e405e1322672d1d3cc8a0e515530c26c8055d9c0f9a2bc56720f7228f8259321fafd5c2495a5fcdbf27f4dd03feedb091e0f9c6b32a25881b5fd32144c1013b16c6be371aff5b4c6678186ee50964e8a29666c8d14a17fa074ab95107e22f80fe7b289a54df4b79201fd4093684110ecc7f6d8e6bc02a9de00d9fd539125c9f69a8dff200dbdb36fc4261db45e8306be2cecb7cee59fb218678ccd8f9d477c89fd4c4d2200f9cfbe0234dc32de8192dca35dd4a19c6222194735a94ded65d771db2bf0d860aa713769d081feba8d6b9952938dda3d5e2ab19e2ebc1abec8fca91271a907bfe7e058e985a6da85468de33100704ad7add7205733ff033f09ca0d83adc30913e341e814ed775ed6cb36be9c908c22116528c9005f88b3c7cbf101ff93c10c75b05a05b6ee11f718a5938ae4ae2a977d8e42466d46798b3f24cbc2b4d7f74ac718bf3fc180b7a20058ef85e1e186e88fd0e2678f7566f0c9e349a330fe81e64a117461ecae9d990b13d556ba259d767865f1ef10de15854703b1348b48549bc9c19a02bdc005ce66db485a7dff24daec58ab6bd3e9fefbc6dc7ed6e35e6dc935fc7e7e2937adf093a0c4d7ec9bbd811ebebdd81a61e09abab9946d1852c92749054f1cf505d2fd54820cb6fa0a010f9b2f60667aa613f2035316fea0ea86320fab0b8fb3ef3ec3f742b8cbeb34c04d69a17eba522d50fd578c210d97ef0b4986b45905a55909a944d44262c6bd7ed0e76700daa64c5889f60d2a4764835233d7e9c850a6bb6f677b8ca1fcb419cf18d6571a0c3608d28f268c114baf9afe7b244ae24dbaafbeb48e3a611fb84f3ff96bc473ca1a473ed91a03d4a034a1f4a90356fc64621eb3ef274fafc8b38b51375a6a44eb8c9b49c1ceedf86c6564db1bd431dce63decec09512d0a58dc79d6bac1c617eafece318d39fb018369ef1a4bb2497d4e70537b200c34f695b97652cb28a90c071ec5346701c84e9a55b46c9ba4f9f110a4f564b1d4630a8caf3e69c21dbc5bb2af8d997076f9c7860359860c71f94889fa94ecba9bc3a4548d7b8bcd6e7fd1599e2c55dece7622b859771f02448533e82b320f6784f8af63c6ca3957d6dc099d771d1b7e7bd11223e50dea0f87e991877c0f91f8adebf5e2379b99fee48c3dbcdf9c2fdd6c9bc537adf2936d452e93ccdfe3996320cfc92ecbcdd8a1896701f2b0110134ffe33e91bcc0e80f41def2c032368a3db3f9c794ba9922a8bbda88b164515ea29e9bb4ced16d30e3888614c70eacdd843315883d384a7b7945ce059e41998a575fa50a3af99bf41a8bd5f9cea14c7a7f43a3d963d3dd7104c03badeda8efc47b9c3a3d968f688d969c82853e502896379b88ac0a44a12c4ccf781c53f7c062d50925ddd87c3b83d0b6ec2191e12bb79920f1626157884b47add089f8990b3d00ec9edd73620bbb23a76f172156f86c19a91f1d9ed301b9157b51d0f264fdbae68c082df4ab781093dbd4d848ca8dad1e7cb827593f5ad34a649658aace7bacee4811ba05d847e15f36c28c4cf2718e25dfa1c77f62cb31c667662bea76163ae2896d999ac7b90e81b34a15d776595670c6dfc55b494053dcaa7602244584fa4248ac0d8e4e2077921348d0c43e6d2d1b4a82c85445102a592309c909ae3604ae946e889b7ec2db261c037f92ad4173cb1fce7f8a7ad235a025589a2ac783d98b5b5edfa488ba4fa4e048b9b4cfb2c67208c8ebabdc01ae68407ce8d73b62ccdfd1cc1d7da123e361bcb9bb5825995047267d2a0f603416ba0c49ba95f527667ad22dab2da353f9140983024565476677ea9cba9442c41ae2a6da29251dd4fa3657173f83e84edd1cff2948a678e66dc0e7ab64ecb45a55a455fb0ced00761de1d9ffa2903209b6486c9cbef3164137986abb10f0e416d217fbeb2f7fc038ad96d9fffc01","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"ffbaae5afb526cc027e519178591f1be"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
