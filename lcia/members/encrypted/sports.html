<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder=""
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="MEMBER LOGIN" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0fe597e705580fa92b7182a3154780b189db3db7dc3dd7564a1a54ce8da8f525e3eb7582cd4f932f58c33121948973395d16f898a3ad182e3fb05a944bddd3b5a29562c2f080d07f33f031f2dfa11c4052ce4d55e2b700698aafe5b02547cbf56b1483ea8cbe1676854302f1b89ff54c7b3db3283590f352dc566426e182cb684d17b92371c01d88709148c882a7daf9009de445e22ca44931e2d9ad58de1ff918b94c97c8688a1f98a8e99b41380be915bbc8440925c4692540dd64e39f5a2e356ca6621431998f575ce5352509ff5393707edba54a7a9c1f77e0fc6e4aeae2464cfef5300ef9299693d90616c70c017e3f7674f80798a396c2d609016db6aa86a3129d53f4a305a7249b19340f2e768b32aa86f74f7fd75ff83213087901bbde7f18a98011794d0b722bdd76ca31c7785e309395f4ec95b1f7af945806bc3f48f5e9b6e7b7bfe9de2125110564a1701990fc1934fab01c14b66c6666f0a986a9a9b10c0159742221791bcb9c882fd9952d98b1fe3e1aac38196547491ea0e9bb8c2726efd9b4641134eef89076ec9d28bcb05b0c8e8800ad9144fe64a8545786bbdd13a2123043ae60690c6aa67a7f9025a6ba0fa3533898921028e9d0f379281220682aa676f0267ada9e0fb4b115cf7d5ac22354828c1982b793180f014ce3278d8f22df4c50b67dc416979dc3f94a220d363011491febc7c58475e53de751fdaa5355e8d953d2402ae352f1b7ac42a4cb0ea302e6445f661c4a8b5760127dada7231397e056d685167b9050952e55f29c23337eabc96f9ab7f8d8c8dd8820e1e4e963993bef3e233006b9d68a303829a1c960aa3985946552181c65e91f35aa19d2823b707ba95f0479aa48e90014168e1840c296503efcc2b5d30d2359dd721df67447563f42ef27b70241a4d536a0d5067c46421b47b77f266c0f6f3dfe6cc539bee9ff0ec1554798323abd18e79c5111a4e089ff51d8155ad70664fcf88f0b1f9328519e73761fc310e8785dbadd882775d73d6d204340faebcf140448efb3fa89bfd108ae82f27d0286a4d119def02863b99181cfc971e6205c2fe52f1d5cdae3d0f9cad03f16637e00498dbf625308e1999ee36f60459144b816539e05d4542e07c5b83a1888b90b7299bd10b60c9284e87fa0fd01e232076d7b2ebe9af3896249c0cbde5241159c00f156c6ac5d980577ab5941018dd155ffc5495e36f82b76f0304c1c573fccd17a02f4fe40d6188736f8e14969debd2be5c1a5fecca5837b48bb40218aa9f1403dfcbdcb29b7aa7a45968d075958b972293020cf26b71013b824a91f635ea02aa8c5b86f1730dec62b5b9faf0e0e9bbd66f121e717b6d11d0d57b9ea1252da01d6c2c53f72cebcd89fa21deb1e2030de6ca480facc0404d16a1272548a44a2f10c2542b42436027cda8d08b865d3c210869a2fd5a4d62989ea1e35c63decff99775b8c4022b89a9c31902afaa8dfcbf875840f155f3a469487c6e2cfcecc13515be071d404667e6ad4499cf20892a5aaec96b99ade0c6ad6a1db2320717bd076d927b931656bf9db0791959ca528cd9088b69d0a5f3723f5b53bac80aa7ec61390af0eeb50bb966dd814a65d7cd86eb5db9487419f68854df0190e6dbb32ce7124a5a33babc724ed1787a7fc0d43e7d09b93661aab048ae35e144bb4c764eff3b26509ad7485ba8b9ad788d5aa48b7d27cc74b1ae2eadc52de9f4bb2a74fb0b57ccbac24502c6ebed76e842dd0c8d97ac6e6b1eb91518482ee980de1b033bbd07a99aa872a1da485dc612f75ef168e4e0c8e5ab16f12ed9a06f7bbd57228a390698671f02b153c46751e91b47d03a528b78f9e7fdddea9920646e183b18d280804da0df2cdbf220328f568eae7ab1451093443584d9cd84cb480328d1c35516e0c0e5a559e203efe6c02883c3850d76e5f685723a70c16d720fb6ccdf0bb4c63735a8947c60fd5f9bf7f95bd65dfa670153a2240680b171d6cc99c170d801ec629e51b3e116aab5b11c3c27299c4d18a3d59b43215209bc6e6383b4600ad66a62575720abb50971b0db3a5796e246b5fd8614f4b39f56bfdd69e2edeb3f773594d168754ebaa1bdd20fe48f8722b63fedda4b819106fbf16a553e4e1b9ae046ca526beb09852d2c14f2111f10072af67948521090293a74fccf1337f0a6dd4be20433fe48fecbf718b36a2b01354b8f56cec1b2740ba52a5ce8052601d3e93ede1382d98781400d395452a3c03a7a78eda39d846876c4d81a2fa349409a86ee7cc58823cf67caef959224c7cb533201a89487492c97e7c1d62066e9b612f8a66035788a619cf25ec2ccb709667c72007e5a1a00c6f5d9369468ae38cfc2acc761c1b830a0fb0107ac85f04abf7d9ee8933c098d5ce690755fd6c17d93e116c3760ed11727bc0b050fd2d76f111d3d9a74df72d4c012657ba4ccbd8499e1ef21cc6483fb593f7ec64084b0782c0bef5a78e2ad1af669e419c2d90fceffc7b6c3c30f94df61407fdc92f0295f6b2ef6a2cea919a2fe7ef63833ee59a0946ca8bd1f61f9b19a903e7a78fc9115c924fb91450ea04f06466ad32cf104ac8fd5005d8baf0c6c27112d4c40aa615464e3a16a03b3edf241dcd99f21af430ce7162ba3170f86ba6c3d8893e1dc68309d1446b19be041c635c3f58649988204a4de8be5bea34bcb0f9fbf9e640dcd43b5dc84a35821ea636c20d32c4bd9ae49d2934bc7b14911f315795e1c35e853939aa5c129de793936e0af8be2c69e6593236d83db2b91f7eee673f0e493257628f0bf8d722282ad28b420700d98a7368f2fa6e83c8c0f552ed2534976ad7b3f49633aaef0504d70548b73cf841d8dcf5c57a84890f79b84b20ae36280e63b2d30b566308ec6b3a8a31302b55175ccc8a73a333b2db863c5d5eae4ab85138ff81de3ed7d662eda04b19e4b9d602879a5fa239f682d5fbdf74e32de0ffee82d772ddcdc66158ea7119253b6ac08cc5462c0462f8755b8346dea9c797e6cfd8c943567c6c00100c60175dcc4141de1d9cbfe610cb8d16efc016c8ea9948717f7e2fd3df803cfc23de8d48f2415a256ec3628d4a762406a7b044b8003125d95feb67700b7b7863a488bfef2a1c7bf9000e0324fc1af35415fee153d3079f3117232f02d4387a6f4a9f6756cd5c05e96e7c9c6cc2fc261a89ccdbefc374fa6eb621c7e74d4e12d32552c017c9abe1fcc725e0f6b59d9a29e2f6cd539c0c15cb1429a4b9f12de23df67e714bd6c020074bf4914efb988bdd8c92cd3359339a049e109daf6f589d35029074cce17bd6f07f6e8fcfbc7dc6ee365a559c7c13c7f8d93565fffa5017e67ea190b8ac3da5aa733539cbb02aab9b085d9b007ee87a9a7bfea2af23672bed840efe8a7ae0c5b7e5d056f72902368441732e231f27b509ce3f659cba253066594302143223ad03e2323f674c589f5c99717f812d6aef3819a46c709740a888b8c9a80b4c87d33e24e454d428f5d7ab72db2ba8e51d11e3e96b50a635479d9e3d9029ce9a9494b8ef0404922b892144c42c1e1f7c2538fae54247d114ad9620a97b1b8399c1af9e227d72d3e2c1d3eeeabbcec85d34214526de62516f9be4475c0a7893533ffdeeb6593102ae69ce33ef46fb3cf4579f6dc99ade80dcf77ebca2d7cd5d4d8f48b888fceed1964a476577b8c8263d79cbe6ea564b5b96ebc665e47e86d99a2e43fb92ad8ad2a084f9e9292bb09184d69096b3f57cf9d668b0f52a12cb4b1b329f148f80b63e995204210164b5b6ffa351356b61b8791f971fbb01daea7db1a426fac3084e1bf77bdb9aa7e6e9185d4059e4219557fdfa9c67f48864b415e851eaf73311c92a7b41e9533fc1580cf3204427bdc5d95a9add0f292c5c014efe001eecb71f1526bd4fc1343cf191531cd0814d50f5437251006f4f7676ff6ff969df627f76ea8b663864380a5aca1b6cb1b9258d4bd184ddd87f857d0c437dbb6796896d75b9d6a9e267db6614c066a970fb5206a994f0c69a8d85b8dc454db2cbbf3eb20652c1cd4f2e62388cfc4ecab4180b6496399486ba0471763d3124a58623b9afbe01cf04263aa6ae6102824eecbb04b12522dd98525ddcdc9158b34308ffe56b750da5f971c713ac7a00acb15d27cae951d2528736451995bb361e190c7705873e4275bf178c669aabf107d364604b48a6d59f2371b01ea1f7bb99744596e10d36586328043f34b47b48c6764973a36ba1d8073b145bc6931f6fec8bebeefc8a885b1d3d9cbca7da032e71009683cdcb045bcbd70e92283529cc3e4a10d812ce8eb5f035b61b83430e84457c9244d6e330100675e7feef6f3850e2e5b7169f5e33c3ef956ce10a5023c5aca93ec17375a8f88b33e7f841fe7939a84e1c0d97f71fcd4cac9b971444d1c8162e9b1f674d4d0ff40eb008903bfa6669da7333987c495e23bf76da386eaace0ec69880e025872c85f13df4fbd155552a0403783938eed026a781ffe45f25c727fdc2f2d197f27493f789d8a8c8a78c204ab8f8600ef2980218197fb89ccfe79021d9f9778bdeca28d7505cdfd188fd39fbe77ad792b7797e6a73b5278eae2a90a897dbc4f8aa06efd915476e4700c6aac48bcd825e7347ee18c3abadc2ce570d66c5fb13a7162384b22dea56c166e1ce36d4a1341a690a90e1e05a2bd4134d55006affd1d9e3976240ac774f7699d8963415c0c6fab352f64853063770a48e7b79a55387b80ffd1e19157c91561d1ce9744106ccdfa31fee1a6a2700ef9092a5d19bb5764103d0a24571ff9042e82f3dfaca7a7b2b67221918fb227f37593e5e0eb573b1614a7fac9d2817fe74ec0c6bc22355255a9b18001269efbb03c477aafa9b4880d750472a0b979ee5c6ca74a271748f300cf793901f7c71cf02ace18aa2600aec6a37b15f47999b45c37b330172c8e571d94a322c42d98674f0d483587fbfc4a6ea5b8a73c758a12d34cdc9894b6ce63cd646939f7f0521cf931fbd6e2dbe6f01974d24bf584f7b8a1c6db1a2f1003c538bb3bd5dae9f883e7b61885fd9b4e575b4ddbb40bf9220a0b738e9aa1752a61c97d1fa3fefab20664ff29d1e39cfee4eee9181a7544c0a7648dafe5be7c34eb87a474b81085b2b61eeea9e4ea03bb1753c9faaed5084d9125fec96eebe9ed9df6aca9b109003a06c61815d97242aaa9f8d074d3a8c5664e6f92fcc05034c22881e4e759400fd2dd18b2ce82c7d608f149603df1a09314ca8719b720de846d3cc3dac7b3645b2a38fef252e9f00dc8ccaaab281d6110c5f93317f0e7478e40ba2c1817b3fb0b9cffeb73f8f56de3674c5975d946ae0d41887921a777e4ea572a7bc83499224ebc81472860f5a8061907f0699c5cdf4f4a622b009150ac337e0d6b31dbd21dd3507650c6300699c660ab384e4dc4f7d9eb5ad21e8a24a22a72b20e0f77aef3d2b977c175ad6114184cf116b3481ddcfcb8838eef6acd509b8d5ea2c5e87f7fb8ffb7c3f6f2a08a933c46da987ea3ec63cb9216804bfe90c07a47cb2fe15e85b5eb7deeacc24b4a7729a00fd86a584bb2e006fbeb975714959e19b92a49d26c4dc73da5f2e35d08ad695ac5c912b96fcdd3d7da416f513eba1bb75f9991591396c1e57f2f72cdb8bc71ba74744c0aed8b097c9728f22c4ef7f86acd2391ed13780e31564239e924bb630df193e839b6e7553f195796673bb08707df570e19f5b7b2bf4efc0c1d76f071d67d5cb19791f774e5fe715190a63e03015344d9677b083dfa942d5bd6c5ca09259eb9a488b020e0a81274c54bc2c84141f9a957df89e0a0f9fdc5cd9579adce6006ed755ad75cef7d20e586ae36f82e20552060080b1fc0c9ffc013d4b42f661bfada9dd622ff3b54e3dc4c17b151fc2e317cc51839b42ec8f59d09064fda0fc162eae103a9def7b92bf10c9c8c84e0dcbc6d9ca2ba0e8fabbe2eece51b7d4ca046962dc685fc7b1903504a35d51715a60b0f8aaaf4b6a9ebff1616127d4b848d5a88b4c6d536787397f2d523125950dafc23984e28fe6f3da078ddced96b8d74c872fbb7e57b5f560a83ba44d50055544dd1fee5dc9df85f5236b11ab6b3d05649f34df6b3b91bb84ff6b5df76079388b3090915b8a49da421bd3d44d59018ba1abd1253e4d63da43b06488e1a5b17ee00f219107c504c814d8b51af719526774928083823ff9090184c179c476e2a23a78a1aaf0193af51728c3a3a93d4bb3087e31a5864a5b03531adb778f7850dc77fd86b5e40ee91e9a9ffd2854bec4d8464fe1af2dd40c73d2d349ff561ce247c85ca19c523c8dab0a9892773cf16f2f27fdb6ef4900278b6d9eafe6a6146aff19137a54d45911fb892d65a2dd1a081b2318ff860e4d1df79ea814b11f9e54def76cd93c5890671ec48f0356e825e3b619d14f80f42f21816af760828e4716c27f50c2ca66d7bf9a60faa5de3cd1805540f930a4a913762d4bb8f4b722756d5cb1771bfcb9d505f2b2dcc0244a044805c3166a67c71db741951d8c1ba2f89db1e41985c75f3095efa0b439bfcd723db74e895c54aefb36238ccd05e911c560f3fe3c73358f06dc9e2a2332698d46e33b1a39c3daafbb3c98f2ae50757de6258deaee32626c99b8303ad6cfb5764c29b12e7613dd0d7b6a212789f67f938486619b251dc237c8954efa757bcd2db8ef331fc28f819a8cb01e1787dc13ffccf7d6112db9508c2992f0427216cea21978808a905cf3cb26a0f76110f55f737581aed7a197d1e71c52c80dadd9f683771a0fbdd1f9ed1193eb947ec174e6234091dd953dc939c1e27d57f62fa7eb3d296dd9291f14adc7429e8198a90050fa964b3653bf47219a6737014d2f17506b9864308194154634d069df559d3b4ed6392e30a277458a8a543c6df50b194f377258aaaf2d24dbf0a43e61a589d62cfbf5a86ef121373116982ea17798a8ba834c65c975a59e695b98606d142cc7638ee9b0174afc5989e73a16980d74128524b2f99e7f16ce49138f9a8518b73480591943587df2a5fc8ef6e3d1b893f6365940cbb6798658c4565b1dc6d71a12f692cc55e884217d396edc5f4ca76b39cb486a2a30a512ee4b41d3b34549f4e078d526ded60228948e8264d6b5e7d1764b033b388e57d6f618fbcb021bc77095be7902668ee01358350446bb09949e9416fe87813a3248a8d8a76ab695d1870db6f0f95ac19acd5bc2e2d87a98b2ec07f9f5c51bc7ee8c5643e9c62f4752970190b3b94bd46e1e7a103e30b40b2b4469351e965b65ad880cb5a646faf333a5c06495111d3d7446e643e28818e40acea9faa7524d5e5a30d566872b69e10d747f65a89175a07ac6fe0069ec39bb907052d95e7d26d270b4538336390fe7cd469c84aa27c80ae36dc224b8a05b382b25c2bc4ddc0620cb6cff2eb91cccb0107b6f2764d5107044fb1fe058749014c10cfcb216b50e7753e6f91af74316cd3f21639b1f910febc39935a48cc9d390e42c3f5e1540d6d48c824284b5e09b6286588762317f224479fe637e5aa3f8728780cb60e6e4c8d196289a3dad233afe177400615893eeb3a3b914e9ebf7e717ded4bc4fa14548de72a0e687cd2b7ed3744d55a163755c84aeccf2eda673717802e9d15deab6e1ae0b0f2c4e74fc1c0401e579bd5595b831e2782b217b981e1790ad63881fa55dba7ddec2766c56bab9ac2bb40a8122ac75225648f2c99f077134b4c60ad3635d36867af591035c353881fc4610ddae325a50f1c7d72892c1044765a0917a57f73ac8423104b96f8208e2628662b18fc366a614c1a87b6d62150f4ba6be5131f0eb740fbc509eff0f6e5d10c3f6e4220e82042267d347a0fe2bbfb440315206616f2f6ac2e95bd8d446a510c5bacc31b863e1b23ef6457595a705bb8dc28d7a5d9a47ca5691b43e451b4d1270a2887a50ee6ae89daa69fa9865a0b0c3f1f4895fcb898a1d9f1b7515f5271e77f6acc873eaad189165b23339ced6d4cdcd7ffe17e147242b86eed65e3b6ef7b6b8551b6602123624cf854938ee66cbcb359ed66e075e7149536b2c9e9073d47df356b5241a545195cc13273478eda3600e2e81d4d73e1c2596c2baf0bb11811bb3e746d4ed2311d76590e25d52c30e95febfaa99bf29664e558cb05aa7b7fa58af51db62c80847baf3a6de6fd25f63d3784faef3914aa139f1010ba4bacc492503bf3e5447bb9bd8a1793dcd36d4ee9be82b3d2e48fed3ee88a2798bffed41037fa8ca392c0d2a3affa5931bebb0116d13a3f5bfaf6dbae34a593f0c490a134a0633e19855ee09d0d5990841e000362d3a563c6409ba7f57ca80f30b29118935c88781033aad96ffc128c09b8c904f0bab3b05a94ba38922dabf55f0ff4bcb779b099ffad2e739299041bf6ffffdafa939c655e915c13f504478d5c0ca3a85690af7c823159a4393b1a8b4e971b2f50b8a4e6a892e7e09b3209cacea73bada9e90c548e2b1414b696373ed558ec1a7bcfd3a3211bb623464acc2755a858b741500fcb6bfba0527611c603dbc4f6580fe7413a9b235831cd768d324f4020494bbbbf0f9a8848283d0d26367d9b4b7c7f2ea72c11ebf6ab1a3af32b8145b6e5af1beea403053e16cd066a1adf55e55569af6b1d23e057591ddd117ceb8227f239b9cd7023bfb0861f0ef66492c4472d6e1bdc7175f409f7d21e5363fffaa03b1ccb268ecc5be34246739ae34e3c23a5ad483d75023b7734fd77f1b78c68cddc5af99461d325de6adaf95bd0647a4bc72015063b25c209d7bba7e0cda92988ab7c636be794f0dd49f92eba2108ed818bbced35fd793c56f0f56c33bc3bc0aa249bf3f678158ab0ea04e4b570e0bc69675e8d0229408deea04bdad29e607b1c770c2973df03fdd67e0a8ae0364ab02b78bc860fd6a02af3883342f0675b8db60ef9f4ae9856f4e1ff70c3854e76700778f323c674ed66b0581a0bcbc878cd55b804884291afc224177597621838ec761a61f732ab6185c5593cfac8242df08f34b72a28b0a7d56575714a20e7745870f5ef6f1f3342680015c5bd449f045ccf0945b7290479462e7f2c411d401320d4cd5b9683ab69004ec48d4a54b2485c574a85181a5e539b05b5966458452d42eba8935ec82f68eb06fe26557aa14ddb86eab983570790f182a3b64f52c1c0db9fae469307b126529467c413962b82b4f34a715e51d9564dfb313927bee7b91e8c1f386a4908baa4bf6a31f036b04f673e751a8e977d57cc8f528bb3e1de2fb5a9d981198af4aa96cef1bb6fad28b13cfdb2bdf319e87c4101319ea54c3ce2f42b915f23f905413d4283c24eaf1e66f21acd4e8b05b2a9535e98692722fcd897c03914f18a19d95295ac5006d44588aaab6b9fde392877e07c9b5b79dff59dc20461df962b24e29da0125a365d7c2657e800c0b468a60f94909968ac094ad7e3f2577f12e5659b85f4d22c3b18fab44fb0fe7f10f6a43ff15ec4f65e74f5ee116110d031ab033f14ff58dad98a24a02bc0ff10c053ec617756a435c19ea95389e5c695fac832bd6208bf71ca712aa1a36cce3be7b2c4e32fd03e83e6f4421fb6c3bdd8c82b8c1a91b96642283ab8f21f0f308d882325d7b975c17f9233fe8d12c8180516cdb9eea95a9f3a34d12ab9a0682406d208283b3f65bc56a55764a630ffc47cdd39576b24cd3c710eae6f0c437ed9db9ce6f3b6188623f9bb5663263b04c785c6a9ed20f85e1d1ae1c1aad6dfe19823a02d9eb75bb0f7de0ba2230fdfff27d1325374cec29c78eaed370c244d07189f30a232a69b47732064a8e87266448ad1cb23c29ca2863051641e5d098dccbbade68bc968da73e3493504cb2dc09304fda142d4ea8501db535bbf88741604e65c4c2205e3904b2975362debc01c0482a6bee47a8a1d958d1e00ff18dedd05dbc3f3a2ebbb278bab62129a0eace5223de8d16e3493163899b2a2adb96ae2f8c4712c661ca8451720e59927c78a1dc9090a56f72f50bc823085de43958918acece3a29ffbf698d104c0bfa9965f0c0ca01d7e2bf180ff23db237d66937f540489894e7f1a162f532f2ef99052caaf8e1f9c859a5025abc8d60c305430d0de8310a955a4f586a8bf82bf2ebe607250920d9b317df080fece8c78339c1766da53163ad4ce8dc443fab346515d2458f4e67bbcf9f48fd78ba81b4a44ed47c2e301ef9a013d32ec2a91a71bf082ff1df27885332d55043ec818b2bb91b95a6c4912b46ccb50dcafb71de3a333c71e516d2cd589f33c0c3b1ae2aa55a2e59b9efe2be58d3d37cc395b6690c604316c1f651fcf10a57cdabf62602744ac89ff60df1562eeadaeb1a1ad8a5c5f36fdf34a2131b6a9d2e8250df61cb125fded3b20a045784b4a23088d1191e570788f690879e94c233bebd10572f94ae466462647e3b082a2479157a0bd0cba91ad9b0d1ba237a6a8f73f228c9a38a4877c33d3042c2755ec2332a459ba2cca8709223c06f396b2f9d813c40321a7b5470aaf948bfe4205caadf0979ad8953b438856b63a4a15df234be","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"ffbaae5afb526cc027e519178591f1be"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
