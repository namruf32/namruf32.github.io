<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder=""
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="MEMBER LOGIN" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4aa06f0adfa988b2b0822ad55cdb7e68ac820e8b3d3c53a70deebe1bfc41c759f4a9c3f60bf2eede6007d72d42cd4bfab65ce68f916a085e130839c41f6556e33ea901d49206be4789f8d04de2e43cde7d66630f420430ecf6b5e31930d2419e9dcbe88804522e4c8fe2c0be27f700fc2c39d3f89fd1159353c466ba50da43f7e33800274003bb4010a16b9e58d92fafeeb1c3f6ab22639dff622c908ceb2822dba776969dd01837b333e78cfbf1f85115d790d7ba0e4505c1e0d65728629fabc586e6bfaed6ff532f0c48f51f5b3300c7007172be12135737aca6ba5afb7ac4632eb8d3095002dafead4984a47b0d510f804f9eacbf8ebe32e70fcb085bdf9ec0f7d1ad07826d67d1a03e77382838762a1cc119faefe3cbf6e57c22c19b639f02f1555a4364ae111fb758e5594c1a85b8574800f371607d24fbefba247055f112c525a0c9c3623cd6972b45967acbeab23b607857f4400599bc56961919ba70c896ddaf2164d2ee9c9dd4a875ca6d60128c472852447edd695ffe5755492131d7d24fa64ad406c44d128a3726f00f36877287f8704381131980565a4ed1682efd93398127690057eccae32c662d33fffc613591aab12fab859b4103122d80e9509dff946b3ae0a1eb56699129488f9450e446c2cafff7645ff3ea45ed33697e0ed9c255a78c9c47f055f29e6de23f64045a4575c8e7d998f0d9db6fbe0c2f22bce33e2b6cd17002b2b943d35649510c443fc8f3e10f9776dca9d5770f221b1921f0ac674dfacb6d5f6b6b71a3359df5fc3113a1f4baddbacf69c1fb70ee97399fd8a34ecbfddc416afbeb7d99deaa7c4def86dd82257768bcd5e1a3f7188f73c4a5442065c7493e13de280bd84a861f7ac06dbba6164d8b0ffee77ad9c5b9bf131a07e29842aa1aa543ac656eb59f6b287610b30f9922f0c3b2651f9618d56e9f4fe667c2e7fcb7b4e331840d227f71f592ac610a0b6a85a8bd6947392b0a125af94c191762246557ed284e500ed2e782de7f3d27000250a35b14594ef413796bd42530274d547254fe00d0721f28d868d7314f3629fb33a51a282bbf4564746b3d6340768315f984e34ada70f88ccb4e519f2bda2d2ef6d3bd8043517a706fbbacf90370e2c12f97cbbd6deed91b784225bfdf428687ab8eff1b17c9b98c24d902bc0fda0c1ac977a849e0beafe09e58ff212fe42c56282bd49adaeb44c90be0cc3a21a9627bc210ac74af036fc1631b446cbc05f1d5564be67237b2c328f908e6f653841b39792df104ed3bf53d29728d38f2ba6abb7623135003235e2c1ad0a636553c69d07b9256a58d86ea0679120513cc612f1ab3a2fbf7f6ab8316508ec8dcd3267a27f9601fe6fb0b6a69563863be9220ad8392fb3f60909b77b76b13c5795f4dcac4e6f888fa72d18de974366bc8727f68425a66573c4d2e57274e94b1a3b4836cda58b5b9b96bc746b5210434277aa9b4324006529161b8b8363d4257374e37c13a3d45921cb0c37e0b5633f5c40ad4b5741e2087a0fbac5f7108c2bb00114c54adceb33baa2cdd1404f16b9e443c060c328b78378151a64d425eef680a518043b0e52593c75482ff5aa9f591dfd2a4adcdd60c70fb3e665f102e4b256d352361f1e2f3a4f33b4f9fad55f53bebac7e54e61c73cf5c7882744de57a34a6bd475867bf6af55e3fa566a801de907c0db8bb4716dd8ec3b66e22fe763caf1696ec5e53e3c92c5c79d5feadc0dd3fb5d91a48828297ea3d38d33b9cf6543c44a3cbc57e49352dac666ccd6809151376ed2a7bcda7b44226cfabc824a3f8b2a15a026f8333151c9657f8e34d81e7a852776345d3300b68b53e6735af2b63305b719068fd0d451e4578fdcbe0e73c96ffede3ffaee634259efdd7344717d704d931be10c0363ebd21c114a5344c9a53c54bd4caa19ae2fbc87b2493e6819c6b52d6e34a9e385fb81f1d868823c991acb9eaf3c508eadf967bda6a66169fe239032c8f83f836c89de839af71b923423ee102f5e9896231acfa67705019c4df090d92c28b5b65ad6c1ff57f027f609e7625f4d1f1e6535875a17b070045c09f042cba9457b12b84926340fb45c6ff35223d9ba7f0110980df52360485eed2a418bed2b093c6e384eec06b265848191045827a0a1ba0c341715d7f81b86d33da5a0a539af768bdd1f4e51ad96b6edaf919ee2453e6c005a628cc09537b19da0ea0b24295f8149083ac99862e69471b02be63bb187354a1fa7244c6144cccfb3418551fae9862de87b40ae6458043d76224c98a8d73ee62eff885f43f608cf548550009e584306225b364a9ae55a4df424d412961b9019df86f4c86a614e130b079ace287778e7bee02ae1a109b4b29a993d1f94fee6c4bcceb3a5b6efe88c3fdd19bd47a566d0210dd2f754057a37cfba95279bf0ef218931e05b3265853b9c1c3f26f8e01acf6dc582f75bd7224ec868d37b2c45500083a7fa28188f4eeabb5569df351408f34e074c320fdc180b9e7b4ffadcc58ead0f2e5a148e6bf4e51c003c52aa096a096cdbe571b683bf32cbfcdc96c45c8cf43f6829718439d1aa8d691c77d8a8f9352ee5d3555e97620810c845f97b042c832fb48d2deb5498946bcf272e9367532343452d8adcb5b16f49729717700bd537b9635cab08466ef4e494649242fa5b7c7a49a125e1b100885e4ea6a5784d4728b1cc48b542da0044cd0d1151691d67c1cb55c7a91ec8aef806882b9f716133c35026fa47577277789eceb67c58db81039527f72cdab0946346a1a525e4899705b8c09f906ad70b337bde44be22b316005317451e6c0a8f9d2cc92d98595395f76d26eab50626e89224157c1616fdc5cbedba038d5daf480d483624752ed25e88b21b8028c34bf8d32d3cb21eecc5d698c05357433436f7713f98bb78d10059ed26f151834697dddd7ddbe72f047917c21c4ab232647361a161c2881aeda619e95d7777584ef86ba5638d1c82a784725e001187e504af857699d321376d4511084521fa19733a96db0fd7bc323bb0d1983188ea1c0cfb264b2db92185551fb6ad7f5c0892e13ee7f0ca1c31b68ea473bcf7b3e4e114075675c5b72ac17994ae49ec2ade391a0b5943850bb342e7971445e10fbf2f0433d2e8ead22a56db34fb6365f8a5ef8f7935ff34dcdaa87fdbacd3dcaf44b335b70a6154b890af4002b5a9c02820855adfebadf092b2615cab6c90628d281c66b70222213038eb1f1a79bc7fa196251ef1324147a3eff1325f4d07d75950e72e126561ade78894da1c1e5afa835d40b395086dd3697c894b23663b2453049b52a9796389133b524f26182ce362f2e803b5b19fe76723a6b2e7581edeb29470ae7bfb618e70e370d3dd408337402dba352675ab1670c42f52ac72ff425a14d0544f68cca65478ca772b0af3fce2c50935b42e091512b0ae17d451d49d01546da1355c3d4295492801cd6e09cf5f3de0cddf10f1997e8e2b2203606ccafd08df697fb106a5976c7d28b553c5d21705f3968987b24cc3e545db68e77a37fd8f1438e5ac08c3f1dcbaf02e24659faf1573a5fce7f0879b63cd929950ac4feeb2fd73f91642b30a1f4d8964e0eb68625126c28ff6511fc0c0deb8a80b1c7cdd9c41466db3404af210559613f740590078ddfd5b318c980a3433eba495783463bc9849c267fb72e7df161b86aae97dce64331a6e1b981f728a6c786e43fca778f3a4918abbc15e0441d5a046e219da1fa8f8578b101dee516dbb478cab9af37e3f13dd8ddb2a9775ed81f5295ce5d9841caa3963ee09228fa871700a1f6753b9aac72714f7e668585e15dc4eac331a24f9287e1ea2e1034bab380c2b3a4da31bc59a95ff4416abd98735bb0770e30b799c390e2ff95d346af426f94cb489afa698165a7465a36cc2b72d5ae0b406a246c29cfe553dcfdb3e6646e843f173835db422097a44a41e34618aa41b7d7ca826b89ee1ae5bb31565329ec9a29fbbdabe8397a320a39c6c4e8dae6c645f532a74f532c1e4e56395dcf1a221a2fbd327dd9e9a302b6d1a26d09705e6f2695ce062e540f5c138d84f9a965a713823550e7135cce7a593684d032abfee7fa1f2027c69c0bab6483f597a1089a713ae45d7af1d76fed1e31f20294f80950b7baa0307950777b8dbaa3432e3f1f1d155454515be34a7ccb8b0b6f29e6c090bc4bfbf3109ae789d542ffca5c223f5bbb060e61d48dac04234d2d7aa19ced12398aaa55557e6b742f76be91d6b180c02e510b34439ee7331ae1da1c1914b8b590ec7dfc2f5098b40d13b23da91ca23d0862a45948424ce028c047b6d2a97e58e1c624d272757e0744196804c352a13a7627d1cad3439260c3de4cf4575488646706a47cfc3ec36c12090949bda77eafa72a7531248615dbe5ee34756652fa7ef301ae9896241fa8ae4f6b1e9fb402e18c6fc1ba812fe91634445c1d46d639007aa5182fb6b67586e8ab2c86b4316c7d2c8e3728c86839abc643279d2068d751967217dc02b537faf7feb29005b8507315608cbf64b3cecadffff67fa8bdbaa71464a7df70146d5b1a32fe2de2348d529a1c29ca4c4b09c0c953c75cb6fa5b959c4c3e6268612137737437744316a15057570defe89dfaf6e635f3bfc3e2125c31d65d0e473eefa5dd007f5ea2f132a1c6aca779463261b8167f56622432735dea5baa476f22a7e0d34115069f25e86ed8209968e447abc7eaceb7b0e5d216823709b24829cbae0ee4bd6ee02f2df3aae752127e0cf3d1153e420feef512cd442ec8ce04d78be4c58a25bd6cfbcbc30bdab79eecf0c486aecbca5af196a73623c1ca4feab9e19c4a246dfc9d4f77961bdaea31b51b5dab310277daf77b3c86ad78840c4b3d2154bcdccdd4470faf86d7c3523519ab5601fd776360bfb9d5a48fac1ca3f940e7f3bb6297002a09d0fd9bd4a0b35f3616b05898acc6376b5a45ac50ff6b8902cc93d1dd5df0cdfe59ca85a6206b82c691ca03fa2d3b25607eb7fe9b5742a5005fc8a0eb4a9b5f711d4c3306e4a6b004702447092fad6a1de8fffb59cb744d4e09210f173c4238509d9aa30e328c51ad53f2ff571e4bbba2b6fcc8546b15ac1231e49453d833d9cafeafcbdde0be45e574744e697a0b8c874f745a07a9ddc83e31f8f01f55a235ba967994bf5cc77cef1125bd618489b3ce98bb547494bb2e0ac4f04e7dc994f42ff1d68b89e8e7f33ff34ac2735890864b2f82340a46a35bd8d29aa511f8e1869ebb448e2f722a358963565bf6f2aca3337d2a12f147ccc62d64975e764f1a229ce63a458bbb5c445607483075e603aa4e8fca9fa785ec5881677a5c615004c9e833736b56530b87e4f5ed91915ebfe70af4e42ea7c49a9b8ebad2fca5babe22bfb09e45bfd7a4a2ab5dc6e747893e3cd2ce371e3e5645bb85406ef0ad28737f71f3bca8ec80e032067487ebe8677d09ab102b23eef1465cf3c0dd4b143eea55e396b2bb28f0ce6b43687a81c39f800b1fce01b7f057aa6c12690be6d0f695dc50449c65481d67569a46322ec8951b51d7cf25b21bba874db14b96fb231212c4ea7da1e777a90cd40d430d0fab7a5ae48588cbf6aa118403403d69f4ed6e7e8103613a166cd710a415958cbf3a73feed6d926d1b3486a5e50db3db1b61ae5f8a66e548d4e6c2805f42adc5cede0dfebbff8599eeccfcd42833e12fb9f287660ce230e0e9e4cfad19d448cacfc2d6845b9d0f6b0b748bdd95c75bf2dc61ebbcf8b592c268881def5f7c4ff8703ce42c62bef09858a8cd2a4a0e62e4b47835f777bbb525643c58c6b89630b13d75b80014a47e56904fbd7de5e8d29798e1aeec37b6731654e81ec48e0ab89447e2f01689eb99788fec0e0c752794e2a09cf73978aa9f79b5bb7edca0de320a5d0596c026a318b818bd8c4df7d144c389ac2144f2dbe976f30a18045bfcf8b77c7d7620f7368c8d4fb7dcef3a8034962268c3d848cf080ad8f97550f8d354af61434f22211c8fcdd6804892961a7c212195ab49b8fcffc3529041def1b2baa1dbca4bf85bd3af37d819060fc7a30f948f2f1ca6983ffc51befedf5b3757940a8933014f8e67de9bd4f096bc6e7d2c4d3d077b5c221c5d1a2e711c453040fdd96bcca80c5002960cc5e3185bef1930ae9f0de7bd23464d07ebde9f6b69f294f14e84c03ee705c182eff28b399ae2b48b9dfa56de3a31a99dcfa518f2a9c09cecb01a6c1194f9a54aa46dd580b8c043fea7cdf80ea1c776b506ac2d2080d585f579433387e79f1276050a9385ba6eb3551e2d95e16be78439da7002d7190ff5f9f5921ff80e290336c432236c315ee5976c87e67bca42a149835ffaa7e36a900eabe455fe6203c001e548ee089999211ef83f5d98083e6cf872b75329412fee77a5f4597c0a7b33cbd0be9fa2d52eebf36cdd82b0ee7bfbd056ef5b7d6873c61fb824e86d59300c6383544a3671f688bacf46ea5da61c75e2fa54ac710ff8550e1f4c85fccd1d6b1d4006bd4e609ff27991627cc1b371ec9b37f7d495c7e5bca8331e5aad3e0781bb826509b482b8a7e102daffea14376ba6b9befe68027e1f3aad908a7b3fcbafba842b130349b00c60dbd097c51832c0d3114bc07071224be9e31091cec421d0817cfd03006f4b63c93dccbc99382bde88e55ffc88bed61cdd190d29cea58e8adbf82c1dbb075534d64070dbed25cd7bc3294b638d2154b64fdfe9389e4ae8342507893ab8ad7ffaec72095c062730fd4e82846adbe1cabfaa87c76073a411cc981fee3232a3bc519f5cfa69e859fe823695681ab91b09acd7769dcf571685eb502cd83db67f466b31473e65d6ad28d0f6091cc5c40a6cbdf12ebeab74b0c538e4ee8c25968bd6e9c76ff6d15708dec601d0ac52a08858658787ed29540538bd31040ef2c17f85c6859c237be05ae8956c1f2e5b51c50f0571c6d57a161aac3007d5080559f473028ad4dce0ed32603cc01986d86c7acdd977ec85fcc70bcb10e86a9ef0bc691e3a4d9e98e36494822d76b10c69c58e25334561b87a6824dc29bdb1e54984a0b3142cd5c7b3715a778273ecf0f828ad2f84e1449aa680ec380b24cd6c3bf4de4ef8aa2b9b8edd8bc4fd7dd085e982217886324cb60f65ea3ed8f537e154c17588ba7993044e0c02ae38311a601f72482da81bea3622b9fd96897bd130a6b85a33ee66acefe9af63943c843391864da5060bec39c466e55ca2375b5c8385dfce5680850e84a3a5684a3a45a53801f8c86c8aef60bbf1fd048792fa535b28debf589d15a63bd8ab3fda033956acde0f0054da38f3867e8b96f31d11fd25b62b7fd9d09fd8156dadefce99b93847ee66aa91dbdaaafc76d7272fa00a86d3098dc3afcd3a91956c362de09386c1cf2fa1cde0745cec5481638f27cc727d32ce7d3e1c9c64d068ea55d857903a0285f8c363f36e5011ab80782392f812e43a749e46e82c7fdfa23f4f78c7cb717ea7ea3a367e635f0078b519cc007d902a2af36c37ffe0184099e74db10b3f67d93e61bba7c73aca8ee2ae82c6b106388ccdc4876678934932b7b6b0edfd7001823bbf7406816788916e3f2e2dffe436b5a560b8f48671be74b929c605de4c32114ab77a734e268c3637334dfd7f235bfd64a88b579ff59dd053101e5bb41ee30897b1a8688e64f7cee9157bbd0415df27ba312fb46658dd0f3360120390b05b69c9b028987d1409320a5129cbdb7c9d78e9b1d3124f93ae6fd39e3fff9bd3d3841e801db1d44b0926f5c7fc6bd275c559f199a7c471deb57dd2b7ead524511e7e6985f763669129018b24736417103c48db8451426f19b310ec9b96f72e3020abeca3eef4674256cc26b2bdda5ae51d9a7b07f96105f6b01c113bc645cc9f9559b41e17b9dd3ce4e814c22bc7fcf59165f07a5f7ac4b5adcab63953811a11f9b6307d18670e37d5d7c7a450e0625d0294d947230dc04a90efc0c0b52a32cfc1b73b691cf0dc3a393a259bfd428bdf91ff391a3261caab9ea3cb8a3fe454e0b18d9e5bb4d5d09a91cdf8f18fb8a7052175afc0b5091dd0a6b2f50237d9a0a0d1c4080ee821b9fedd9de3095284a50f9bbc9894d658ad18790a9cc907428bcc5719cafa50daa83e975ce90637279ada1ad4d7280d15ffb4b0bac5b648c9677c7287620c40f5209e4f99d7f2c6b298b3176b91c2e18ab414a2a69c759a2280545d3b91442d199763f4f322be0d1601533b19c1da4d6d88b030607cb39de87f32eb38acdc54979b8afafbf5ee0c777aee8e71670f50f1ff05704044b705def00d8f725322c7b9b36022ea4304326c5aea4aab43a04ebaa836a3d64e35928321738255618fd97011a20a414e95b9a497b5ed5483c1e48399fb7da9efb5a08f24ccb732fc5ccb8c2d059041b8c64a1ba2f762b0dd5c32e04f8b93ea14305e410805f28625e5ab8d91e694c2c490156158a15eb6e1c84e9a9c6cb0283c4261d18f7d88d2e4929f65940ccc97e2a03635219de9877985845344d7b94342cc66e91863669f94df0d48c939a1e184d8f532007c23b3424429a1008a64c1807f0b926e42200dd22397ea4ba8062a68f1a1c32fd9eff807c28a1a2b4be4645633e7b62b9d8f481e6a71c48fa4c2f3b191ef62e964c02d09352f4a94ba467bb1a2bf2a26e60b6a946829361c04a9f5988415978aa5bfe50e7c8d04921b6336c760e122070eacd4e95a658633e5397d41d09e512910d260ea0dd053dfcd937db2bade944f9b168ede1bca0079ea6b8384c5193752f91f250ba20ad58890b276a6723d22da77af5e770035ef472efc48aa127402c22a7c3809187b69e19c9b8239c25182bea1b93ac612707b4d5e4e6f189376b33e948e73a087db7d53f4163549ce1dcfe8e1bed093812ff5dbcbfd87a2ce1edb121485f234c8c3efa218f7dab6c2ae2bbd21a7fb7972c8e84cf9d26d8d4d75e7b74a51167e4cb47092994dced2c7cd751246d8e29b7feeacc48b785e82f01f311b7b455ce50db9f638fcad88245b32c910779015c7ad3ea3723cd3c9d055b13b03256dd019ff6dd6de11dde24ed1ca2a006cb5c7f4fae4e6bed53c2f6c41b31f2167ff38242b16e04bfac76a53a5719143a1fef8597fe87832359225c6eb16256fe81e44dd8e5bd2b47e754d74cc6d112619f4f11775f8c1fe7b97a9d027806e269bbb55a1354ea0d618c83304e296cb521349974fdb9c11966f62f36258d73aaf1ad229fa3bdb18a4db969b4e9c6d36ca2fb9778ec679cfb2c6a418482d82383c41b4080b4a798b2fef71ff06c0d008a3a9655a0156f3d346d802287983e1be86f43d9e05fe1de98a3be20a5649fed4fd9fe62a260d2392283fc64a5dc85ab4c894b74f88380763b69aa2cf3889a64a36e254403c720763732effbf7a135ddfe0be8797cd149706a297e4f2216c0d8c6224da5338a90b8fdb5043b58a65041384e456338482761c9d9924566c7cf8f18f57ac6e319bc686b0989b0c65499327928fc100df79a665d110391c6fdc634c39612259c6f0a2448107bf531766cf1235ff05adcf9266efd018c2c240b774fd1c6ea1525689d661fca665559dd441100dafe849e0118a20f449f293bd98b6d30e2a5c91591a3b021b02e25afa7d8cb8962d8dc09a552b75dd0e410dc0772a609c47bbe9420946102be2a07906f207ed7a4a7283d46824fe6614adb306cae0156eb8d50efb8c77d022aa945f49689fc11f2a5ccd47e63079306503267debf11c3f9be71606dc9f296507d6b9fdfee49faf122ca140d58b42dfd31807c26ecbff64141068dc5250f0e4b9dbd72d7fb5fe84e5a298525e6d94033f5f5978d15590ca2ab2d39fbeff1299f58799f30170c57f293eb2048c59545fd5ec291919e0b7fe0a4c39793d19c506510e890c68c5f3dad9fcf745edaf9d65946fdfa77a812be0c59f1cb8e26490c91a491b8784532d68c5d00f04327e282579e54d8a7bc75c33af84d7eecd5198322b76a654576dea37b2ac59dba1af8949cea2a2e893f14a062c60c34e8d342967f29dde25cb84e1ebb34f8dfd4abedd152ee24a73b8b0aa47f263dff0b1c4dbac52b56ad0e09d204d7339e2a46c547ede205df0f588e76eb02b0744dbe8eb97c292c0377cc44574921c48897dfdbc8c74291a2b33829e1ed51b21453d02177adb61b3aa7471a7624d689c1355fb0cf6cfe2f8fe39bf722cbfb706b8aa40bcde8003e41dd739461469045b3a794e86db729eb5ae05a18bc03209a737ae1305e788deabca5da8c56254beced6a8d17ebfc279671e9d8c63703ab6bd30bf03f8b3edb5595629a35b3a5bb1d1208b555d10405751205202300c797210fbffe55e6bfbcbccb4e3ec3ea18b546c7804a033039e3c3fc61a7eff70ff6d60c5cd5bdffcb9135297d994ab6dfc2979c62179f03ebe6e493673f6479027d49d7042e6adbba15fc513b6733b1db76ae6cf941bb8bd61f6cc5650e49d3f2e296d26fa6b5c614869aa229f2a4f0fb4d81ea3ba73d645a03696f2143dc461abb3e96211f75136ff40c935617871","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"ffbaae5afb526cc027e519178591f1be"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
