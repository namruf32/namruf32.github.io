<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder=""
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="MEMBER LOGIN" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf40f5492cf3abfe725110902a4fa2116f59a03477132353b0f940dbf0811a7f56c34e4027d0adb7913eff18c90c01d807d569db8ff29a530e3ef076ac49fc3307fccc20f2befad6adcf2b7c44fec25ea1ee498c414dc5462aea800480ab02dcb38819b2f190332a100e9076700d474f5b3f314eeba741d7663de0a5d4cab8d0c97e8bb2cb5f2a6cffc596bbc9f297242ab68cb88aed2db0f05e382653536ed79a0c848200174c33de34e84233260637c02fc8283562b8d2a42fb461785c461f74591007d8dfa37522f48c9865a4a990a3e6896b3287d069b7c3b648d818d27fe85900553069f81cff97d5d65b05ded7ed6567940b6cc720c25a27f1515b58ecd138827c2d251daf5a64311aaff31bc56a5acb11903cf6efb9d891ae6076609a496dde62ad9dea3a89bcbe11600b655e76f99d9ad6bff3a7fd989026f930506c62039489ff2745d5a492f82ef5e8b7ec5a4c87309499b25415fa61fa4510e3bdeeb9d848eabbcec672a12bc0b5bfee985716098825ec7ec222cba204ab0e7550c20aa5d40c8f18bea517296292f65e6c2d6ce82465b5f48acf7d0a98da1ff943e933aed3848c211456e33afa7129310640324393671195dc7b6f95db551860e96c6e5d43b08984b35bcd3394f32cb0717e857475552bf958ed4cd845f6aa77700bca57688b3fccf1b5a40f794a32856431497ba19fe8619551efa4c4366afd382548d7276497773849d37ac22e3ce9c946f0b083281ea15276924f107d6ee3b94f54926cba7b6ed3195f7a6b765ec555f23421350460d67228d75201103b67907a838a22abf2e478c3743d1dd77de40b9166ed4438b526cbeefbcff360960fbac4355ae8eac1f79910ea8260f432338c398fa4b0ff0b8fb562c4c087e0827ade5e6dc68b9dec23798ae0c0895a6060ca7b7647fe9ad6d054b8918d5daf71148f0c344a77d45e800d86de17882a2f70718e1ac3aa328f0f3bdbc8af20e08198152bc8f774fecbfb48828a9aa44b7e20b71d9f0f2ef9ff229c5ac910bf62bc6d39fce4cf2c873c5844dd9eb237f481211b591e9ed0e8c63e55d28b67b13de3a2004791581597764fecaea070460837a4c65090796738974d91bc986bc38428e6e0d63653b81a99e6985fea8a22d957625070f0b4dfe9fa164daa5109894cf0d989f98297ee14988968c53de175f2452df5722dd8b3846408088060b6409cdbc854ef2c9d1fe12be3709a60e461b813444591b0bceb6a59f1bef569aa4083781d2644d0a11b24c6d71bce70df41f9296ccf00b21e55a3011a61308a0acd24124c29f4254e8b7a25b4530ec51deccac4bf58e4cb102a6d4ea2804d542a22ef3f254dcb62ef665080a338b8db78ad538eb42b1516f19bf01b9f4c7319f135853303d516d9f4b0f604eb105c6dd35068eb66324827693b7fb88c2e304535318023c90aa76eeab219322be2aff84951be8b6e14aaaabde98c14a501ec83df54908531d54825e0c1e8b6e5d2c6d1ca8edb3d69228c449c0c2db76fea0440bd2b0156a96c0cb35c6c77f650f8bebea7f20b88d88ba84be09560d5efe221ffdcef87ea11b5b654e9fc46a27aa3e42561c8b4480d99208e9158c1e8a3d146be1b929f8d6e0d0e7d33159937b77bd74b302af97a363546c13535b545cfb6164ce5ba5ac7530efb80f68730915f10160022f73df066486cb95a59d00e7393c74bf7d9ba63a0e37b3c20c343502b92062eb2d3f215d0585d3b5fd2fb9a9dd1e61724a58fbf3f86173393ad26632ce03fc2ae0e0379a4ffc79203b9cd939c1f50d853625aa6e4074f516515518f1bdd6149262ea177672a440bb087797a348dc17d9ccee0aecb0c584faff7fd824e9e39db90ad40268565ecbe762aa292014231eb6462ac7f48293e337e4229c1a7dcdbd18a3041c010b47696805b4b755271ed3f91fb5ed9fe69044f99d56f3999b46a37f4e6206f38da706b9ac3026939ca61f81cebfa7c4637b850ecbeeb9977c169d696572fe6bd70abcf53cdbd48d6bf07bd4ea157872ed364f7d1535bee39c25eeec377ac7fed1f5372a57a8b04f224ea25269894e1406285c4efcf3d31f54d2dad56de9efa6dc106c1334ac9a7660827ff58aeb545664ad3a857f764a7a21b62bfe369c9a167033b92d31b9df71ea80ead05b3ada477e8584907bb207d5e7889135ae35ccfd3baa72c0328573f069704278d44497f32725cc9f3abebc449897155cf2eba6abbf4da0605990c8a5f93f213094f02beb49005fc50bc12c783dfee47156f2bd4bfb91e1c00fc368899017f8bb6c6979f231acfb1c63104fe30b47909c8b02808d5e8c6d07973f29fcefbc92187ddb736414276c2714bd31fbe96136837acdf32a3217260357a416d13152bfc27622f5cf326745f559331c48b90b43f01f4a885a0cb4f743ee44e15b23ce30c5227a39cf7f816e1758d74296b6020eb85bc8ebf88c32fd772c1fdfadfe8e175815f21af30c1c24318c7567fe73298f194465eea8d79b47306d48d88bcb252ea094d0e344282ca4e98c27ca9abebbd547c6eed82808dcbe579d674f3b9ec1ed60f087923749aa67f3e3e8b5933ff589341f8f9da91c2a504711fd12d86eb912a61066c9fe9ec554df61cc6c41620042f145912b93a00e4e85a6aa9d1d514b8de876e5f2640ec7246c8ae8a80283821afeb75a1a92b36bae8334d621c0f6506271cf34b542c0a8f3e9d21f3be1fb95fc463246897418e574911ef19cafe8b7058184dce581fd352b8285c726f02a87e71909883d2539442f8abcdc33e5686915c4e9bde8deb34a28d61339be2e811823921583d0542748b42382b78e76dd330d9428b2ffe7f1eff9cfe740a0539d45202ec9ec8e5e7989cb7cc572f085109a78ca14c0c0b1937c1e4c9f291a8e0b123966d2993cd419e7fbcc7c33af853651cb3fe6b5c41d5b6caf77e13033c06fea483a023d0e8eed74de453c7b23f4e08033f20c0f1f8f880672b6b6720d5d5a200dc9cd4453a17a37652f1f418d658b956b5b2d7ace60e1a39dc372c512c750ad30d1e5e313f6b4e0afc9120ec4edb5ecac06292332b441e40701b2cfafa48eea1cd77349b43d595a2078a716303034c91a8ce455a266dc016ebd52f34a9157feb0a9a173ce3eeac9fe4f1467e9daa49fbbb1ffc90df60f34d4bbcc79e4224d41b0cec9d256b5e2cf97176d36348f3d872d8ae7742a74cd40e0b7a802e8b7b54f26f1afdeef445184833c21fc3a5d2ba0502642b2affe2729d026a69a3dbf470f1b610072d904a1c62d90002cba94727424f88078516fdf1f16550db6950c36f32160a026e31b6570147898f8d2ca42bbd075a357956e79bb53dbb6024ade465148bc93bdd0c5620e1197a7cb3116aeabf10f899d58b06e22af382d5980ae874136897f6fa9fd8d2e55aad896f73972ac34c5fb35e3ba69d7a09ca0a9a9516ef81b127550ea036b0a2d847d0aaafde7f337f09bce9668057f202e623a2470062d66b33392ce4548b7a2a9890fa32a60a5f9b86c26d1b299086e57806918742ca16109bfffdc17d34dc91d6af4a244cb965af9513530834cea4fb8ce4ccb0593a6fa56fa585394617070f3a0994084eb25fbd064d43a0a1e569ce66f6e623519471a0215734257422418869efe0e92ddaaa2dc2ee00813f6c1ef0299396832e2781f00b4df9292b9de7a66cea8cfe7e50e17b82ae3e6b7ac026b613c2033d8c862c17808e5c3accad2d51f61b1d43c445fe5e348ef715ea14872dded9154d247c657a81814b8cbcceaa9b8e6223faf554e646f739295167ec3aae706626f2e3a9b2076a10cff4d9242ebb5fcd01b2ec7251b7694902278bb65881542a4218b2a27379941bba4304c5f3b81fd2e91e3bbb697efe914b47105bbf5f9bd10c43a4de57cca707c01262e6fb1b4ea7c5b9f67c50b2b7844bd5578fbfcb31106ebe70c24cd036127bf7eb12b64c7c5e1d8c04870c9a5baaa4be55efd56c5ba2fda8809aa3b350da8c7f234f5e1d24a834e01a58db9906df570cee3c9d130d9e038beaad33f43344b3a6a1ab9a145785659f0789c5c3d890f7509f9508054ad453a770053b8729d073860e06ca1f0610cb932874c8b3a621bf3a149d170a5c899895cab0ebe60406b502ab126e0facbe52fb48b19c53b417f1b5b700673fc7e5f64802549b2325fb175a3b20b45cedbc973ef7da3578ebcebcad29f012e4b15fdc06433ac2d2d9d1f3c5c09296f7bba48f2ae79f9640ff5728528faf4b6ff9c77efd6364a695b8233b64951bb247c661f469b246b6875b1f86b23915c3d4e5e7acd8768b16c9020b71ca62c4befaef0df04fd8d6a9cd363a7c8c0be950c7fcbc731335ee34cfd949fbeaa2b265c54339ae97d3f86412c0519ff154c65f436db1735a588ca992c2d02aabbf5ebf00b046ae2e364e579d56861e9d58374301a1c5f7a392c5c2930dcd52e0e8ef7a8f3ef72c56cc7a56b52263ca446df3342080d0ff2f6e9bbcc4a00aadd75ce287e8f4b5145e4f419c52f3af17b327dc341015a90e6e719e734248d4345e475ac795c81cf8ba3b530c2b785825feac49f7471546f147fdf17d7397b2cda6ed058a74ab6350dbe11b152298669f74cd34d9ff06af4b2897b9d2b93ad0adeddec233c633ca302aa049f01820c645193207812a469f998d5db7561d426b8cfda975e0a97a59d000233ff510c1cdbb7f7b6c5b6e312dcc66ffaeb65e9a083943658a00fe868ba46211cad7eff9baa3e1bb95d4c4ec03d6c4887f19699fd86284abf7a5d2d0b75e6d3d903dced55a7bac70b87e09be95084ab0bca8a7069d120b88ab208be764f91cb89269611adafb5918031efc08cf879ce3597ad0dac3a5ed3e10b79c5ea1d5ca85a03e7807972fe3718de807419a2f998f90657c2e405d7387b681cdf31a4b14c8d21c9b00a5371d8aad8da8e0c70d2d7525fe5e9b24e2f5303f5d39b3113d58e1efd5af80b0478105a621f1ffff37f3e13151b2310d439041056b47016b556ce9c432a968d150c639c021da2488cb25f8816544450ebe24f5517f82499e0ff859023b50e97279fda2bd58584a12ad6bc6d1786841317d0b2ac14eaf23415d0d63087b6f0260eff213da41c56a7ae019a51c70b94038020166eba2804fd9677bebae345cbf6ad830e4767fa4ed8fe949989c682e9db3a48dec4785b40e8a6d3b95a5fbb3daddc0bc664e78522cea17e768c7e3a451bec1b7187a1b6cf08cf3cb990e49804ccbeefe4d94154e59a29417f89bc8cacaa1668daf5b0e7f78a124885db998e16623168cdfaea995284dbe590641ae774e36f22a6b302abf72d386ecc54537162b7add90bcc4365f66a2573af08d78ba5d00b5d5307300d4a0a87fe4ec04b44fabfa2d45ac4e5958aa04b970a9035f60f8900eb261e99e695ab1337680650d40682743d63453375202618012d4862bf150593bd29b40c08cfb28f040cf4888882935f85022721a4ff1d4c9569eef73d9c744012e56079c727e249f0314ed45d6a9da9cd03287455d1db4a50fe6f3bff2a8dd98abebce6bcb3a722f7c554467b22afcc82715968fa25cee31af95c9f6f40dd0abf8918f60fcea04d7619a2c7abbb0edfaa453967c1436815ef7e303d07a6dade751fecf38c4c708f91acf07fa1e022445cfeb3878385039de06aa6ab67be254b6314a9493dfce45f67509868b6f2f9a0cf71f7d6612685658a29676558ab94fd0be819e6992d9a9f8f73e2eeb7508dda04d5d6c4f4d31c380e1fe46ee8eac35c305881baedf9865ada66f864530486213824122e98655fc1be83bcde3c48a581bca3717716abb0e40e1ea3cdcf057e688ff35aed62a46909c8fb4d2a3212d57336a9639c62e925937282eab8403677c77bed95f656defb0be83dce5720746b4de535a56509362d2d19a3a47ecb9f41e03d21635fab33b28015cde5c381668504c91341f0c623ee73a923985c6bbc81e9a8cee6104bc9dba94ab5f6b694ed67b26c879b6ca293cde5121510b94440d2620b9275e8b051deb94be7cbd9234562cca575b0d61fa3c850e90d9b67e92de26565dd819c5e769c3770da61baf274dd369e02a3f3ef255d1784835fba2b6e31983634d90b66245831529492fa9e49b86b5c2219f38d73b7e73c71200b78681d45c54d7b7a949c3c527dbc0a7f96f671fa97db0cb7566fdcc9c2e4360cc126d7dff1d4410133fbe04eef1e5d1392503ae58690721f77b53f961115ed6d3ee2c84adcdc81ee7e08d2ce78ba536809819fc8f8b451b1d3aeb80678d7293ec8aec05131f1fc1f70100598121da0c210637b1f52033c8c676616255586c180127ff56fa76bcaca13252527bf2efd42e281d0c72e38f8c5c40fb59cda330eaf4e4a9736d23511885610ef851b0979723555de320b36cb1074259375ff0827c6907e5ea0e648c0fce0ad88a47a28e5b8552b93c1befd13cfc70068bb2f7e841769b58ccb447e18d2974b1e0969103cd596e16353ae7e7d207a52084e60e690f92bc24708360903046b878c593c573ee80a6daeba6c3c132a9e7d48d818b1cea01f438aee9695d0f1475d88a7ecb30756dee6b1c02deb5a39d2ae112ccc727e364d421e1bfa1008ead40fbdd595b76bd917c3c9f205953cd5125506d2687946043514ef827b7e2f5375d268e8a303e6c8643f932d1d8d176bb3a51ee8eed2994f56c411bc8849484a5800ecca266a05a528b2ba667080909b61a272b194fbf0066040002632ed091db7219b093724acfad16c3ee02559915bed3b997a0f7dbe0f18e95d15b630cf5debd911dc68a466af4759ed044655733a20a6250504e158c74b61d6c5bc7e9ad3f90b35e15f42e805216e7a0cc6e516042017c6dc75dfd291db6bedc9f5e8824564da8683fa8f328b563490742ab6d61e0670993e85a5b38fe0642af7d8bece22476d65e3533878574b9a5ab8872aba13afd32b360f8062eef72f62ce1f1c6a6c88c482d4e7231199a42866454e53ce9ce493925cc6e13a8af630468ee884cdcf7798a20c165e156d3df67169cffd677ac788de998780e0c37aae4cc7ab8b4cf44176744e9138140183931d34f7bfd7acfb3155a87a13444ada624e3829a82437634663e4d140c82d916349d17ab006fb8dcdb24c616a8cf90ca8d00b3c12c67467d4800c8183595c5a89393b8784d84eb3c2faa9e116135003349cca2e1c7228aba96981b9ef9f2ff8f9cc64206812bafeb02f9cc21823d2197ae42587a0276a6aa35796b7943ffa10bc1fe514066a1cd0e876e90b3d0de2234641bb22996a04a121d0872c316f32a993837fad8f1732702661977893b4d7a6ae9c64098fcdee82f1935250e7ee6de35ded407118b2e65ca4c1ae152aa1085f374c3a33ca6ffee39a5d3eabaa2fc6f4d42103610bb9fc4eb58ce2195cf2752fa573f369e02b35a3e17edc77155fdd4cc133b999ef913bc8edfbb7725ad5a7001b5e3bb6ffe4c08f27742836586cac23d529128e511db035817b0753caf52309af0b5e9a8320aa4ed281a9c7c364fd8c98591fedc4b7daba23aafa259c466428d7486e743a24e2c8f9c04a4a18bd4884db0713189c8e7b67dc75797b6fa87f5d19c06e3fb92a8e86a8db71cbe094d74778e8c309b9968d663fcab5085e3a56c492ac0c84d0c6b753669480fe6a76b515f6dd04c2321cf705887be8ab4a41e56fbeac6a8daa37519dbe69cdc4930fe0a187848f658a8d9b83546990d465052e7dcce8b50d3583c415f58ff8721339f2c159bc5534175ad7541827c4deecf2a1f142b9556db7decf79dcc1ce7843e20d9c93e65e569aa8a79f6a165b90bd0f3dc17cd2d605a214f56e32bda27c6df411a3ef0105127902e9eb7d6120f3a8e43f41fa9f21d293cfbfece04c8aaa941d280232b4bfbc4fa88b52bbf66de3fc1810cba8411ec5dabb972768dca28684a371615e25a96c7b718649c43199b3c21b23482d522e1cbfbc71651bb53a9e0d0683f18cbb8ea82e5108a9762b5a78d7d4c3752c80e3a81aa8e5fb00cf844284344e037bda68ca58056e68062ab39ca5d33d4a69d2532f6731020d9e815e11cdbc782e43e58bb506f445107c17ba3d067f3eba40216eb070abda33f44a1a97cdb8a0e6228601fbc16b8186595de51c33e6aedb7945326c2ed38886f8cbcd2ab8426fb68bfbfb9bcb2ba0252bedc3dc7415e65a286aafbc98098fca15fb3f0ebcc5c13877a9eb6abb7e1bab26e0a7785c970222b3df69ec8e07f674c29d2d05e8e13b1bba86b84ded90f3248e4d3175c0b8d8f5fabba346715d25a214dd916a221c6220bbd6268a0f7c01a4e98cb56964b668cb8e03de5500c846472370f288760e3e9786ba98b221e0b2af5fb74f928f7da7e33d186ea53b4de9094581f7153c6dc0845c6a369ead03dd4b3ae6c4696b99bee7b59dc95d3ec765097fa0ea02fabc6bb85f3c6470b1f71058e754612ba6f3a3697514cb36776fff33eea34f3439df03d30d60c0a50e3390098554cf25a5dc351e9a1f6d9b9829f8a2e967205480c9d8a25e0a58f2ff6116bffdf6b2ec868938516834265ef8b0f5fc40109f1a998d54d0a13efa02341cdf355e6b1fcc2a43cdcada898ec78f63f28a1255a94b730475c424a55608e5885b579d9e61ed6a63e143f31e70a8568a8a5ce4248b8f66830bf246c2ee504b8923a6d9218ee58d2ed9ef3c0a10426f99e5edcfcd3b37fb72984ce6b85263fdd1b75125fc5eb73b6dc688feb68558465c4443551610f37b2ed69c2e33e6abab06e05ddc6939c4da2e707db838429cf298d48621fc1a3ad59f386ca5de5e274872b4dda9e665bf8a804f9899075c88b109f820b9264676fe02f1123396144ddb3a2af44a4bfc88188c79f5164da4a9d6f346f33d2c5a05de0e59ffa064edce980bd10dc0bbb04c754fe01400e37fb997d2aba8b5480dabc1ac2dd38ae60e92cf4a7544366a0468a1bdd4f6759c0697ee0920abf4054d9935b802bb6378c6257bcef9ad42ab680af095f3c7123c469336bd32ec6940dbf454c2f4b99adf69ca1b093dd317cfc22985166ee987244381f58a00065d640fb692c3a27e2f56670e7b6aa6f23ee27144a426d2f166704b95638793d2b9684e504d3c0819f2b3e88c335d5925572a2c93a7b5e616f3c20bbd0c8e4a753ec55bd1aa17e2b86af0adceff366dd2240a90b055d91830012ccf08ebd00a5db2e8b270bf720e98f49872b4c0328ba3e0cc1630ba66773012c936f93bac3526c437989e7a0467b56f0bb7739a66545cb6d943d485ba68b8459c17f3edaa7f71397108d9ce5eea06cda0bee1b5497e18e262ed24d9b1d87ec0b14f07c1bcc68b74560118993bb431c7f7a7d8dc80b2cdd19f8870de3b2ad84d74297c611a4988930f697a8e7e83a9a1b358949e519be60f8ffb2fbda84796e30ef4b7033fd50647836cc63a6322bff70a33e6d9477d47ebd4066f10c254450a847062e11fea6702778fb5e583f7d68731cc9b22f6435b0edee05b63c9710b6e4d6e6ad32f893000f52b6f5c546696ac27a694166c4d263c126f88e69b3d323542d799904cb8d47ecdceff922df324d7154813eff0370fd1f5a27e7671553d79769bd3fa4ecac41bb85dde3edba0d06ce79f86069b231628b05794ea6eda3ef05c8b60cce9eff2407ecbd62617ab1d3549bca1cd42acbb66810370eacea60c5439abe49ac108586323e8361c2a653a1b323178824b07092d58d16b9be53d77675e490e4ad82931c9ff59b1c957e50e5113ef0980d6332fdbdf8bf6d7a1b63a950ce2d4b04f9080efb55962df50de63a156a7d80d9091eeaa66aee425348592d2195f5dffbd6ae37d8da23661bf49cd88cf2d4afd6daf0c88d38749bc174251d8c5a6e46f4c4050992271affebe60f818b1994ea15ada729f9284b0fe6200e5838e386f82c1e9ef9ef4d19f0f6664d1c75c98fc87361fed5a21fe1cb19c0bcc26ccfd0749b05a6760e0e1ab61b244ebae9998c0ba8b26a98f82cc147d029f71b62afccbfbc884a82a5a33cd19e94e0e36f5ddf7c3fba173fa7abbfa6901072e025a311ce52808e1ab141d259623c6a215eded0b395a1a7fb21de75d59ea1e1ca71bdba8731f608a8255923fc02850cb487eb21dd8d832067f0174803e87113936788d49868ab95a545176112c5491230a3f8572294c57e56a0861fed6f3dc9c22f7b448ddf7bd3935e780f47d182e4b70f9a7db151777ad6ceca0d77c81e6da85355a67730eb4fe7f0583f783421aa4ca251adb633650af863c7d2cfe91d07025cda623de3eba2fda7b46df84e0fa2112fae0f0cc2ee9bd7b2411e67e706829d362d769fee6333fa28fe5ec30881729c0b68c82861f19f939f0850afa4efab67e413ecbebe57272daa4b339206d403380410a535e1cf3ad16e458e97fb1a66705fffe3161405b61c182211178b8936891dc934813b8a90cc073dbdf96ac6cbcbbdbb9303d09301872e45c3b76c2430800e10bd50960bb1c0ea9599fbb3dee40856dc3085208f4688f9018af37a0d033862b880090f0f2463ed9af4c36ef770c8c0b786a5d80b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"ffbaae5afb526cc027e519178591f1be"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
